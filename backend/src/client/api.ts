/* tslint:disable */
/* eslint-disable */
/**
 * AIBrush API
 * Orchestration backend for AI Brush
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@aibrush.art
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddMetricItem
 */
export interface AddMetricItem {
    /**
     * 
     * @type {string}
     * @memberof AddMetricItem
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AddMetricItem
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof AddMetricItem
     */
    'type': AddMetricItemTypeEnum;
    /**
     * 
     * @type {Array<MetricAttribute>}
     * @memberof AddMetricItem
     */
    'attributes': Array<MetricAttribute>;
}

export const AddMetricItemTypeEnum = {
    Gauge: 'gauge',
    Count: 'count'
} as const;

export type AddMetricItemTypeEnum = typeof AddMetricItemTypeEnum[keyof typeof AddMetricItemTypeEnum];

/**
 * 
 * @export
 * @interface AddMetricsInput
 */
export interface AddMetricsInput {
    /**
     * 
     * @type {Array<AddMetricItem>}
     * @memberof AddMetricsInput
     */
    'metrics': Array<AddMetricItem>;
}
/**
 * 
 * @export
 * @interface AssetsUrl
 */
export interface AssetsUrl {
    /**
     * 
     * @type {string}
     * @memberof AssetsUrl
     */
    'assets_url': string;
}
/**
 * 
 * @export
 * @interface BatchGetImagesInput
 */
export interface BatchGetImagesInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchGetImagesInput
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface Boost
 */
export interface Boost {
    /**
     * 
     * @type {string}
     * @memberof Boost
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof Boost
     */
    'activated_at': number;
    /**
     * Balance in 1/2 gpu milliseconds (.1 cents)
     * @type {number}
     * @memberof Boost
     */
    'balance': number;
    /**
     * 
     * @type {number}
     * @memberof Boost
     */
    'level': number;
    /**
     * Whether the boost is active
     * @type {boolean}
     * @memberof Boost
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface BoostList
 */
export interface BoostList {
    /**
     * 
     * @type {Array<Boost>}
     * @memberof BoostList
     */
    'boosts': Array<Boost>;
}
/**
 * 
 * @export
 * @interface CreateImageInput
 */
export interface CreateImageInput {
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'status'?: CreateImageInputStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    'phrases'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateImageInput
     */
    'negative_phrases'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'iterations'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'encoded_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'encoded_mask'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'encoded_npy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'enable_video'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'enable_zoom'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_frequency'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_shift_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'zoom_shift_y'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    'model'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'glid_3_xl_skip_iterations'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'glid_3_xl_clip_guidance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'glid_3_xl_clip_guidance_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'height'?: CreateImageInputHeightEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'width'?: CreateImageInputWidthEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'uncrop_offset_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'uncrop_offset_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'stable_diffusion_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    'count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    'temporary'?: boolean;
}

export const CreateImageInputStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Ranking: 'ranking',
    Completed: 'completed',
    Saved: 'saved',
    Error: 'error'
} as const;

export type CreateImageInputStatusEnum = typeof CreateImageInputStatusEnum[keyof typeof CreateImageInputStatusEnum];
export const CreateImageInputHeightEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type CreateImageInputHeightEnum = typeof CreateImageInputHeightEnum[keyof typeof CreateImageInputHeightEnum];
export const CreateImageInputWidthEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type CreateImageInputWidthEnum = typeof CreateImageInputWidthEnum[keyof typeof CreateImageInputWidthEnum];

/**
 * 
 * @export
 * @interface CreateServiceAccountInput
 */
export interface CreateServiceAccountInput {
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAccountInput
     */
    'type'?: CreateServiceAccountInputTypeEnum;
}

export const CreateServiceAccountInputTypeEnum = {
    Public: 'public',
    Private: 'private'
} as const;

export type CreateServiceAccountInputTypeEnum = typeof CreateServiceAccountInputTypeEnum[keyof typeof CreateServiceAccountInputTypeEnum];

/**
 * 
 * @export
 * @interface DepositRequest
 */
export interface DepositRequest {
    /**
     * Amount in 1/2 gpu milliseconds (.1 cents)
     * @type {number}
     * @memberof DepositRequest
     */
    'amount': number;
    /**
     * Boost level to activate after deposit
     * @type {number}
     * @memberof DepositRequest
     */
    'level': number;
}
/**
 * 
 * @export
 * @interface DiscordLogin
 */
export interface DiscordLogin {
    /**
     * 
     * @type {string}
     * @memberof DiscordLogin
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface FeatureList
 */
export interface FeatureList {
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    'terms_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    'privacy_uri'?: string;
}
/**
 * 
 * @export
 * @interface GlobalSettings
 */
export interface GlobalSettings {
    /**
     * 
     * @type {string}
     * @memberof GlobalSettings
     */
    'settings_key': string;
    /**
     * 
     * @type {object}
     * @memberof GlobalSettings
     */
    'settings_json': object;
}
/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {string}
     * @memberof Healthcheck
     */
    'status'?: HealthcheckStatusEnum;
}

export const HealthcheckStatusEnum = {
    Ok: 'ok'
} as const;

export type HealthcheckStatusEnum = typeof HealthcheckStatusEnum[keyof typeof HealthcheckStatusEnum];

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'created_by': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'updated_at': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    'phrases': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    'negative_phrases': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'parent': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'iterations': number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'current_iterations': number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'score': number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'negative_score': number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'status': ImageStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'enable_video': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'enable_zoom'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_frequency'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_shift_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'zoom_shift_y'?: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'model': string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'glid_3_xl_skip_iterations'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'glid_3_xl_clip_guidance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'glid_3_xl_clip_guidance_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'width': ImageWidthEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'height': ImageHeightEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'uncrop_offset_x'?: ImageUncropOffsetXEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'uncrop_offset_y'?: ImageUncropOffsetYEnum;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'stable_diffusion_strength': number;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'nsfw': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'temporary': boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'worker_id'?: string;
}

export const ImageStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Ranking: 'ranking',
    Completed: 'completed',
    Saved: 'saved',
    Error: 'error'
} as const;

export type ImageStatusEnum = typeof ImageStatusEnum[keyof typeof ImageStatusEnum];
export const ImageWidthEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type ImageWidthEnum = typeof ImageWidthEnum[keyof typeof ImageWidthEnum];
export const ImageHeightEnum = {
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896,
    NUMBER_1024: 1024
} as const;

export type ImageHeightEnum = typeof ImageHeightEnum[keyof typeof ImageHeightEnum];
export const ImageUncropOffsetXEnum = {
    NUMBER_MINUS_896: -896,
    NUMBER_MINUS_768: -768,
    NUMBER_MINUS_640: -640,
    NUMBER_MINUS_512: -512,
    NUMBER_MINUS_384: -384,
    NUMBER_MINUS_256: -256,
    NUMBER_MINUS_128: -128,
    NUMBER_0: 0,
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896
} as const;

export type ImageUncropOffsetXEnum = typeof ImageUncropOffsetXEnum[keyof typeof ImageUncropOffsetXEnum];
export const ImageUncropOffsetYEnum = {
    NUMBER_MINUS_896: -896,
    NUMBER_MINUS_768: -768,
    NUMBER_MINUS_640: -640,
    NUMBER_MINUS_512: -512,
    NUMBER_MINUS_384: -384,
    NUMBER_MINUS_256: -256,
    NUMBER_MINUS_128: -128,
    NUMBER_0: 0,
    NUMBER_128: 128,
    NUMBER_256: 256,
    NUMBER_384: 384,
    NUMBER_512: 512,
    NUMBER_640: 640,
    NUMBER_768: 768,
    NUMBER_896: 896
} as const;

export type ImageUncropOffsetYEnum = typeof ImageUncropOffsetYEnum[keyof typeof ImageUncropOffsetYEnum];

/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    'images'?: Array<Image>;
}
/**
 * 
 * @export
 * @interface ImageUrls
 */
export interface ImageUrls {
    /**
     * 
     * @type {string}
     * @memberof ImageUrls
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrls
     */
    'mask_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrls
     */
    'thumbnail_url'?: string;
}
/**
 * 
 * @export
 * @interface InviteCode
 */
export interface InviteCode {
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteCode
     */
    'created_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    'created_by'?: string;
}
/**
 * 
 * @export
 * @interface IsAdminResponse
 */
export interface IsAdminResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IsAdminResponse
     */
    'is_admin'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    'invite_code'?: string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface MetricAttribute
 */
export interface MetricAttribute {
    /**
     * 
     * @type {string}
     * @memberof MetricAttribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricAttribute
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_by': string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'ends_at': number;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_active': boolean;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'gpu_count': number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'amount_paid_cents': number;
}
/**
 * 
 * @export
 * @interface ProcessImageInput
 */
export interface ProcessImageInput {
    /**
     * 
     * @type {string}
     * @memberof ProcessImageInput
     */
    'status'?: ProcessImageInputStatusEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProcessImageInput
     */
    'include_models'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProcessImageInput
     */
    'exclude_models'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessImageInput
     */
    'peek'?: boolean;
}

export const ProcessImageInputStatusEnum = {
    Pending: 'pending',
    Ranking: 'ranking'
} as const;

export type ProcessImageInputStatusEnum = typeof ProcessImageInputStatusEnum[keyof typeof ProcessImageInputStatusEnum];

/**
 * 
 * @export
 * @interface RefreshLoginInput
 */
export interface RefreshLoginInput {
    /**
     * 
     * @type {string}
     * @memberof RefreshLoginInput
     */
    'refreshToken'?: string;
}
/**
 * 
 * @export
 * @interface UpdateBoostRequest
 */
export interface UpdateBoostRequest {
    /**
     * Boost level to set for current user
     * @type {number}
     * @memberof UpdateBoostRequest
     */
    'level'?: number;
    /**
     * Whether to activate or deactivate the boost
     * @type {boolean}
     * @memberof UpdateBoostRequest
     */
    'is_active'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateBoostResponse
 */
export interface UpdateBoostResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateBoostResponse
     */
    'level'?: number;
    /**
     * Balance in 1/2 gpu milliseconds (.1 cents)
     * @type {number}
     * @memberof UpdateBoostResponse
     */
    'balance'?: number;
    /**
     * Whether the boost is active
     * @type {boolean}
     * @memberof UpdateBoostResponse
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateBoostResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface UpdateGlobalSettingsRequest
 */
export interface UpdateGlobalSettingsRequest {
    /**
     * 
     * @type {object}
     * @memberof UpdateGlobalSettingsRequest
     */
    'settings_json': object;
}
/**
 * 
 * @export
 * @interface UpdateImageInput
 */
export interface UpdateImageInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'current_iterations'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'status'?: UpdateImageInputStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'encoded_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    'encoded_npy'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'score'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'negative_score'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateImageInput
     */
    'nsfw'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    'deleted_at'?: number | null;
}

export const UpdateImageInputStatusEnum = {
    Pending: 'pending',
    Processing: 'processing',
    Ranking: 'ranking',
    Completed: 'completed',
    Saved: 'saved',
    Error: 'error'
} as const;

export type UpdateImageInputStatusEnum = typeof UpdateImageInputStatusEnum[keyof typeof UpdateImageInputStatusEnum];

/**
 * 
 * @export
 * @interface UpsertWorkerConfigInput
 */
export interface UpsertWorkerConfigInput {
    /**
     * 
     * @type {Array<WorkerGpuConfig>}
     * @memberof UpsertWorkerConfigInput
     */
    'gpu_configs'?: Array<WorkerGpuConfig>;
}
/**
 * 
 * @export
 * @interface UpsertWorkerInput
 */
export interface UpsertWorkerInput {
    /**
     * 
     * @type {string}
     * @memberof UpsertWorkerInput
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertWorkerInput
     */
    'status'?: UpsertWorkerInputStatusEnum;
}

export const UpsertWorkerInputStatusEnum = {
    Idle: 'idle',
    Active: 'active'
} as const;

export type UpsertWorkerInputStatusEnum = typeof UpsertWorkerInputStatusEnum[keyof typeof UpsertWorkerInputStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface VerifyLoginInput
 */
export interface VerifyLoginInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Worker
 */
export interface Worker {
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Worker
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'display_name': string;
    /**
     * 
     * @type {number}
     * @memberof Worker
     */
    'last_ping'?: number;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'status'?: WorkerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'login_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'engine'?: string;
    /**
     * 
     * @type {number}
     * @memberof Worker
     */
    'num_gpus'?: number;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'cloud_instance_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    'gpu_type'?: string;
}

export const WorkerStatusEnum = {
    Idle: 'idle',
    Active: 'active'
} as const;

export type WorkerStatusEnum = typeof WorkerStatusEnum[keyof typeof WorkerStatusEnum];

/**
 * 
 * @export
 * @interface WorkerConfig
 */
export interface WorkerConfig {
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    'worker_id': string;
    /**
     * 
     * @type {Array<WorkerGpuConfig>}
     * @memberof WorkerConfig
     */
    'gpu_configs'?: Array<WorkerGpuConfig>;
}
/**
 * 
 * @export
 * @interface WorkerGpuConfig
 */
export interface WorkerGpuConfig {
    /**
     * 
     * @type {number}
     * @memberof WorkerGpuConfig
     */
    'gpu_num': number;
    /**
     * 
     * @type {string}
     * @memberof WorkerGpuConfig
     */
    'model': string;
}
/**
 * 
 * @export
 * @interface WorkerList
 */
export interface WorkerList {
    /**
     * 
     * @type {Array<Worker>}
     * @memberof WorkerList
     */
    'workers'?: Array<Worker>;
}
/**
 * 
 * @export
 * @interface WorkerLoginCode
 */
export interface WorkerLoginCode {
    /**
     * 
     * @type {string}
     * @memberof WorkerLoginCode
     */
    'login_code': string;
}

/**
 * AIBrushApi - axios parameter creator
 * @export
 */
export const AIBrushApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetrics: async (addMetricsInput?: AddMetricsInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMetricsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images by id
         * @param {BatchGetImagesInput} [batchGetImagesInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetImages: async (batchGetImagesInput?: BatchGetImagesInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/batch-get-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchGetImagesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: async (createImageInput?: CreateImageInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount: async (createServiceAccountInput?: CreateServiceAccountInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/service-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAccountInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new worker
         * @param {UpsertWorkerInput} [upsertWorkerInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorker: async (upsertWorkerInput?: UpsertWorkerInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertWorkerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorker: async (workerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('deleteWorker', 'workerId', workerId)
            const localVarPath = `/api/workers/{worker_id}`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deposit to a user\'s boost
         * @param {string} userId 
         * @param {DepositRequest} [depositRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositBoost: async (userId: string, depositRequest?: DepositRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('depositBoost', 'userId', userId)
            const localVarPath = `/api/boost/{user_id}/deposit`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log in with Discord
         * @param {DiscordLogin} [discordLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordLogin: async (discordLogin?: DiscordLogin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/discord-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discordLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a login code for a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWorkerLoginCode: async (workerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('generateWorkerLoginCode', 'workerId', workerId)
            const localVarPath = `/api/workers/{worker_id}/login-code`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/assets-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the boost for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/boost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the boost for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoostForUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getBoostForUser', 'userId', userId)
            const localVarPath = `/api/boost/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the global settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSettings: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getGlobalSettings', 'key', key)
            const localVarPath = `/api/global-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageData', 'id', id)
            const localVarPath = `/api/images/{id}.image.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDownloadUrls: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageDownloadUrls', 'id', id)
            const localVarPath = `/api/images/{id}/download-urls`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upload urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageUploadUrls: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageUploadUrls', 'id', id)
            const localVarPath = `/api/images/{id}/upload-urls`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaskData', 'id', id)
            const localVarPath = `/api/images/{id}.mask.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getThumbnailData', 'id', id)
            const localVarPath = `/api/images/{id}.thumbnail.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorker: async (workerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('getWorker', 'workerId', workerId)
            const localVarPath = `/api/workers/{worker_id}`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a worker config
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkerConfig: async (workerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('getWorkerConfig', 'workerId', workerId)
            const localVarPath = `/api/workers/{worker_id}/config`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/is-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the boost for all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoosts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/boosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages: async (cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInput?: LoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log in as a worker
         * @param {WorkerLoginCode} [workerLoginCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAsWorker: async (workerLoginCode?: WorkerLoginCode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/worker-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workerLoginCode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ping a worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingWorker: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/worker-ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage: async (processImageInput?: ProcessImageInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/process-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshLoginInput?: RefreshLoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the boost level for the current user
         * @param {UpdateBoostRequest} [updateBoostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBoost: async (updateBoostRequest?: UpdateBoostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/boost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBoostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the global settings
         * @param {string} key 
         * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalSettings: async (key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateGlobalSettings', 'key', key)
            const localVarPath = `/api/global-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlobalSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: string, updateImageInput?: UpdateImageInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a worker
         * @param {string} workerId 
         * @param {UpsertWorkerInput} [upsertWorkerInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorker: async (workerId: string, upsertWorkerInput?: UpsertWorkerInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('updateWorker', 'workerId', workerId)
            const localVarPath = `/api/workers/{worker_id}`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertWorkerInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a worker config
         * @param {string} workerId 
         * @param {UpsertWorkerConfigInput} [upsertWorkerConfigInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkerConfig: async (workerId: string, upsertWorkerConfigInput?: UpsertWorkerConfigInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workerId' is not null or undefined
            assertParamExists('updateWorkerConfig', 'workerId', workerId)
            const localVarPath = `/api/workers/{worker_id}/config`
                .replace(`{${"worker_id"}}`, encodeURIComponent(String(workerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertWorkerConfigInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload the binary image data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageData: async (id: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadImageData', 'id', id)
            const localVarPath = `/api/images/{id}.image.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload the binary thumbnail data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnailData: async (id: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadThumbnailData', 'id', id)
            const localVarPath = `/api/images/{id}.thumbnail.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verifyLoginInput?: VerifyLoginInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIBrushApi - functional programming interface
 * @export
 */
export const AIBrushApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIBrushApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetrics(addMetricsInput?: AddMetricsInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetrics(addMetricsInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images by id
         * @param {BatchGetImagesInput} [batchGetImagesInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchGetImages(batchGetImagesInput?: BatchGetImagesInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchGetImages(batchGetImagesInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImage(createImageInput?: CreateImageInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImage(createImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteCode(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteCode(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAccount(createServiceAccountInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new worker
         * @param {UpsertWorkerInput} [upsertWorkerInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorker(upsertWorkerInput?: UpsertWorkerInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Worker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorker(upsertWorkerInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorker(workerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorker(workerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deposit to a user\'s boost
         * @param {string} userId 
         * @param {DepositRequest} [depositRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositBoost(userId: string, depositRequest?: DepositRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Boost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositBoost(userId, depositRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Log in with Discord
         * @param {DiscordLogin} [discordLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discordLogin(discordLogin?: DiscordLogin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discordLogin(discordLogin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a login code for a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateWorkerLoginCode(workerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerLoginCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateWorkerLoginCode(workerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsUrl(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the boost for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Boost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBoost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the boost for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoostForUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Boost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBoostForUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the global settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalSettings(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalSettings(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get download urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageDownloadUrls(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageDownloadUrls(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get upload urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageUploadUrls(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageUploadUrls(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaskData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaskData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThumbnailData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThumbnailData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorker(workerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Worker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorker(workerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a worker config
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkerConfig(workerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkerConfig(workerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Healthcheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAdminResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the boost for all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBoosts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoostList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBoosts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImages(cursor, filter, limit, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInput?: LoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Log in as a worker
         * @param {WorkerLoginCode} [workerLoginCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAsWorker(workerLoginCode?: WorkerLoginCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAsWorker(workerLoginCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Ping a worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingWorker(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pingWorker(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processImage(processImageInput?: ProcessImageInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processImage(processImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshLoginInput?: RefreshLoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the boost level for the current user
         * @param {UpdateBoostRequest} [updateBoostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBoost(updateBoostRequest?: UpdateBoostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateBoostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBoost(updateBoostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the global settings
         * @param {string} key 
         * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalSettings(key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGlobalSettings(key, updateGlobalSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: string, updateImageInput?: UpdateImageInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, updateImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a worker
         * @param {string} workerId 
         * @param {UpsertWorkerInput} [upsertWorkerInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorker(workerId: string, upsertWorkerInput?: UpsertWorkerInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Worker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorker(workerId, upsertWorkerInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a worker config
         * @param {string} workerId 
         * @param {UpsertWorkerConfigInput} [upsertWorkerConfigInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkerConfig(workerId: string, upsertWorkerConfigInput?: UpsertWorkerConfigInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkerConfig(workerId, upsertWorkerConfigInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload the binary image data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImageData(id: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImageData(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload the binary thumbnail data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadThumbnailData(id: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadThumbnailData(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verifyLoginInput?: VerifyLoginInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verifyLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AIBrushApi - factory interface
 * @export
 */
export const AIBrushApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIBrushApiFp(configuration)
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetrics(addMetricsInput?: AddMetricsInput, options?: any): AxiosPromise<void> {
            return localVarFp.addMetrics(addMetricsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images by id
         * @param {BatchGetImagesInput} [batchGetImagesInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetImages(batchGetImagesInput?: BatchGetImagesInput, options?: any): AxiosPromise<ImageList> {
            return localVarFp.batchGetImages(batchGetImagesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageInput?: CreateImageInput, options?: any): AxiosPromise<ImageList> {
            return localVarFp.createImage(createImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode(options?: any): AxiosPromise<InviteCode> {
            return localVarFp.createInviteCode(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a service account
         * @param {CreateServiceAccountInput} [createServiceAccountInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.createServiceAccount(createServiceAccountInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new worker
         * @param {UpsertWorkerInput} [upsertWorkerInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorker(upsertWorkerInput?: UpsertWorkerInput, options?: any): AxiosPromise<Worker> {
            return localVarFp.createWorker(upsertWorkerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorker(workerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorker(workerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deposit to a user\'s boost
         * @param {string} userId 
         * @param {DepositRequest} [depositRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositBoost(userId: string, depositRequest?: DepositRequest, options?: any): AxiosPromise<Boost> {
            return localVarFp.depositBoost(userId, depositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log in with Discord
         * @param {DiscordLogin} [discordLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordLogin(discordLogin?: DiscordLogin, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.discordLogin(discordLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a login code for a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateWorkerLoginCode(workerId: string, options?: any): AxiosPromise<WorkerLoginCode> {
            return localVarFp.generateWorkerLoginCode(workerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl(options?: any): AxiosPromise<AssetsUrl> {
            return localVarFp.getAssetsUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the boost for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoost(options?: any): AxiosPromise<Boost> {
            return localVarFp.getBoost(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the boost for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoostForUser(userId: string, options?: any): AxiosPromise<Boost> {
            return localVarFp.getBoostForUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(options?: any): AxiosPromise<FeatureList> {
            return localVarFp.getFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the global settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSettings(key: string, options?: any): AxiosPromise<GlobalSettings> {
            return localVarFp.getGlobalSettings(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(id: string, options?: any): AxiosPromise<Image> {
            return localVarFp.getImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getImageData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDownloadUrls(id: string, options?: any): AxiosPromise<ImageUrls> {
            return localVarFp.getImageDownloadUrls(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upload urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageUploadUrls(id: string, options?: any): AxiosPromise<ImageUrls> {
            return localVarFp.getImageUploadUrls(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMaskData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getThumbnailData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a worker
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorker(workerId: string, options?: any): AxiosPromise<Worker> {
            return localVarFp.getWorker(workerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a worker config
         * @param {string} workerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkerConfig(workerId: string, options?: any): AxiosPromise<WorkerConfig> {
            return localVarFp.getWorkerConfig(workerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkers(options?: any): AxiosPromise<WorkerList> {
            return localVarFp.getWorkers(options).then((request) => request(axios, basePath));
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: any): AxiosPromise<Healthcheck> {
            return localVarFp.healthcheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin(options?: any): AxiosPromise<IsAdminResponse> {
            return localVarFp.isAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the boost for all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoosts(options?: any): AxiosPromise<BoostList> {
            return localVarFp.listBoosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: any): AxiosPromise<ImageList> {
            return localVarFp.listImages(cursor, filter, limit, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInput?: LoginInput, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Log in as a worker
         * @param {WorkerLoginCode} [workerLoginCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAsWorker(workerLoginCode?: WorkerLoginCode, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.loginAsWorker(workerLoginCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Ping a worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingWorker(options?: any): AxiosPromise<void> {
            return localVarFp.pingWorker(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the next pending image and set its status to processing.
         * @param {ProcessImageInput} [processImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processImage(processImageInput?: ProcessImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.processImage(processImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshLoginInput?: RefreshLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.refresh(refreshLoginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the boost level for the current user
         * @param {UpdateBoostRequest} [updateBoostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBoost(updateBoostRequest?: UpdateBoostRequest, options?: any): AxiosPromise<UpdateBoostResponse> {
            return localVarFp.updateBoost(updateBoostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the global settings
         * @param {string} key 
         * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalSettings(key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options?: any): AxiosPromise<GlobalSettings> {
            return localVarFp.updateGlobalSettings(key, updateGlobalSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.updateImage(id, updateImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a worker
         * @param {string} workerId 
         * @param {UpsertWorkerInput} [upsertWorkerInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorker(workerId: string, upsertWorkerInput?: UpsertWorkerInput, options?: any): AxiosPromise<Worker> {
            return localVarFp.updateWorker(workerId, upsertWorkerInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a worker config
         * @param {string} workerId 
         * @param {UpsertWorkerConfigInput} [upsertWorkerConfigInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkerConfig(workerId: string, upsertWorkerConfigInput?: UpsertWorkerConfigInput, options?: any): AxiosPromise<WorkerConfig> {
            return localVarFp.updateWorkerConfig(workerId, upsertWorkerConfigInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload the binary image data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageData(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadImageData(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload the binary thumbnail data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnailData(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadThumbnailData(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(verifyLoginInput?: VerifyLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.verify(verifyLoginInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIBrushApi - object-oriented interface
 * @export
 * @class AIBrushApi
 * @extends {BaseAPI}
 */
export class AIBrushApi extends BaseAPI {
    /**
     * Add Metrics
     * @param {AddMetricsInput} [addMetricsInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public addMetrics(addMetricsInput?: AddMetricsInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).addMetrics(addMetricsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images by id
     * @param {BatchGetImagesInput} [batchGetImagesInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public batchGetImages(batchGetImagesInput?: BatchGetImagesInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).batchGetImages(batchGetImagesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new image
     * @param {CreateImageInput} [createImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createImage(createImageInput?: CreateImageInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createImage(createImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new invite code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createInviteCode(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createInviteCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a service account
     * @param {CreateServiceAccountInput} [createServiceAccountInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createServiceAccount(createServiceAccountInput?: CreateServiceAccountInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createServiceAccount(createServiceAccountInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new worker
     * @param {UpsertWorkerInput} [upsertWorkerInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createWorker(upsertWorkerInput?: UpsertWorkerInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).createWorker(upsertWorkerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a saved image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteImage(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a worker
     * @param {string} workerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteWorker(workerId: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).deleteWorker(workerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deposit to a user\'s boost
     * @param {string} userId 
     * @param {DepositRequest} [depositRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public depositBoost(userId: string, depositRequest?: DepositRequest, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).depositBoost(userId, depositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log in with Discord
     * @param {DiscordLogin} [discordLogin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public discordLogin(discordLogin?: DiscordLogin, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).discordLogin(discordLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a login code for a worker
     * @param {string} workerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public generateWorkerLoginCode(workerId: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).generateWorkerLoginCode(workerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the assets url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getAssetsUrl(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getAssetsUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the boost for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getBoost(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getBoost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the boost for a user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getBoostForUser(userId: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getBoostForUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getFeatures(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the global settings
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getGlobalSettings(key: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getGlobalSettings(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a saved image by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImage(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getImageData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download urls for image assets
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageDownloadUrls(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getImageDownloadUrls(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get upload urls for image assets
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageUploadUrls(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getImageUploadUrls(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary mask data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getMaskData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getMaskData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary thumbnail data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getThumbnailData(id: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getThumbnailData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a worker
     * @param {string} workerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getWorker(workerId: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getWorker(workerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a worker config
     * @param {string} workerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getWorkerConfig(workerId: string, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getWorkerConfig(workerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of workers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getWorkers(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).getWorkers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public healthcheck(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).healthcheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the user is admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public isAdmin(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).isAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the boost for all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listBoosts(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).listBoosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images
     * @param {number} [cursor] 
     * @param {string} [filter] 
     * @param {number} [limit] 
     * @param {'asc' | 'desc'} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).listImages(cursor, filter, limit, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by email
     * @param {LoginInput} [loginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public login(loginInput?: LoginInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).login(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log in as a worker
     * @param {WorkerLoginCode} [workerLoginCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public loginAsWorker(workerLoginCode?: WorkerLoginCode, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).loginAsWorker(workerLoginCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ping a worker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public pingWorker(options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).pingWorker(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the next pending image and set its status to processing.
     * @param {ProcessImageInput} [processImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public processImage(processImageInput?: ProcessImageInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).processImage(processImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh Login code
     * @param {RefreshLoginInput} [refreshLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public refresh(refreshLoginInput?: RefreshLoginInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).refresh(refreshLoginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the boost level for the current user
     * @param {UpdateBoostRequest} [updateBoostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateBoost(updateBoostRequest?: UpdateBoostRequest, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateBoost(updateBoostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the global settings
     * @param {string} key 
     * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateGlobalSettings(key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateGlobalSettings(key, updateGlobalSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved image
     * @param {string} id 
     * @param {UpdateImageInput} [updateImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateImage(id: string, updateImageInput?: UpdateImageInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateImage(id, updateImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a worker
     * @param {string} workerId 
     * @param {UpsertWorkerInput} [upsertWorkerInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateWorker(workerId: string, upsertWorkerInput?: UpsertWorkerInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateWorker(workerId, upsertWorkerInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a worker config
     * @param {string} workerId 
     * @param {UpsertWorkerConfigInput} [upsertWorkerConfigInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateWorkerConfig(workerId: string, upsertWorkerConfigInput?: UpsertWorkerConfigInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).updateWorkerConfig(workerId, upsertWorkerConfigInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload the binary image data
     * @param {string} id 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public uploadImageData(id: string, body?: any, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).uploadImageData(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload the binary thumbnail data
     * @param {string} id 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public uploadThumbnailData(id: string, body?: any, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).uploadThumbnailData(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify Login code
     * @param {VerifyLoginInput} [verifyLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public verify(verifyLoginInput?: VerifyLoginInput, options?: AxiosRequestConfig) {
        return AIBrushApiFp(this.configuration).verify(verifyLoginInput, options).then((request) => request(this.axios, this.basePath));
    }
}


