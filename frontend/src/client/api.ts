/* tslint:disable */
/* eslint-disable */
/**
 * AIBrush API
 * Orchestration backend for AI Brush
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@aibrush.art
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddMetricItem
 */
export interface AddMetricItem {
    /**
     * 
     * @type {string}
     * @memberof AddMetricItem
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof AddMetricItem
     */
    value: number;
    /**
     * 
     * @type {string}
     * @memberof AddMetricItem
     */
    type: AddMetricItemTypeEnum;
    /**
     * 
     * @type {Array<MetricAttribute>}
     * @memberof AddMetricItem
     */
    attributes: Array<MetricAttribute>;
}

/**
    * @export
    * @enum {string}
    */
export enum AddMetricItemTypeEnum {
    Gauge = 'gauge',
    Count = 'count'
}

/**
 * 
 * @export
 * @interface AddMetricsInput
 */
export interface AddMetricsInput {
    /**
     * 
     * @type {Array<AddMetricItem>}
     * @memberof AddMetricsInput
     */
    metrics: Array<AddMetricItem>;
}
/**
 * 
 * @export
 * @interface AssetsUrl
 */
export interface AssetsUrl {
    /**
     * 
     * @type {string}
     * @memberof AssetsUrl
     */
    assets_url: string;
}
/**
 * 
 * @export
 * @interface BatchGetImagesInput
 */
export interface BatchGetImagesInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof BatchGetImagesInput
     */
    ids: Array<string>;
}
/**
 * 
 * @export
 * @interface Boost
 */
export interface Boost {
    /**
     * 
     * @type {string}
     * @memberof Boost
     */
    user_id: string;
    /**
     * 
     * @type {number}
     * @memberof Boost
     */
    activated_at: number;
    /**
     * Balance in 1/2 gpu milliseconds (.1 cents)
     * @type {number}
     * @memberof Boost
     */
    balance: number;
    /**
     * 
     * @type {number}
     * @memberof Boost
     */
    level: number;
    /**
     * Whether the boost is active
     * @type {boolean}
     * @memberof Boost
     */
    is_active?: boolean;
}
/**
 * 
 * @export
 * @interface BoostList
 */
export interface BoostList {
    /**
     * 
     * @type {Array<Boost>}
     * @memberof BoostList
     */
    boosts: Array<Boost>;
}
/**
 * 
 * @export
 * @interface CreateImageInput
 */
export interface CreateImageInput {
    /**
     * 
     * @type {StatusEnum}
     * @memberof CreateImageInput
     */
    status?: StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    parent?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_image?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_mask?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    encoded_npy?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateImageInput
     */
    model: string;
    /**
     * 
     * @type {ImageParams}
     * @memberof CreateImageInput
     */
    params: ImageParams;
    /**
     * 
     * @type {number}
     * @memberof CreateImageInput
     */
    count: number;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    nsfw?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateImageInput
     */
    temporary?: boolean;
}
/**
 * 
 * @export
 * @interface DepositRequest
 */
export interface DepositRequest {
    /**
     * Amount in 1/2 gpu milliseconds (.1 cents)
     * @type {number}
     * @memberof DepositRequest
     */
    amount: number;
    /**
     * Boost level to activate after deposit
     * @type {number}
     * @memberof DepositRequest
     */
    level: number;
}
/**
 * 
 * @export
 * @interface DiscordLogin
 */
export interface DiscordLogin {
    /**
     * 
     * @type {string}
     * @memberof DiscordLogin
     */
    code: string;
}
/**
 * 
 * @export
 * @interface FeatureList
 */
export interface FeatureList {
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    terms_uri?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureList
     */
    privacy_uri?: string;
}
/**
 * 
 * @export
 * @interface GlobalSettings
 */
export interface GlobalSettings {
    /**
     * 
     * @type {string}
     * @memberof GlobalSettings
     */
    settings_key: string;
    /**
     * 
     * @type {object}
     * @memberof GlobalSettings
     */
    settings_json: object;
}
/**
 * 
 * @export
 * @interface Healthcheck
 */
export interface Healthcheck {
    /**
     * 
     * @type {string}
     * @memberof Healthcheck
     */
    status?: HealthcheckStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HealthcheckStatusEnum {
    Ok = 'ok'
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    created_at: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    created_by: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    updated_at: number;
    /**
     * 
     * @type {ImageParams}
     * @memberof Image
     */
    params: ImageParams;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    parent: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    score: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    negative_score: number;
    /**
     * 
     * @type {StatusEnum}
     * @memberof Image
     */
    status: StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    model: string;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    nsfw: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    temporary: boolean;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    deleted_at?: number;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface ImageList
 */
export interface ImageList {
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageList
     */
    images?: Array<Image>;
}
/**
 * 
 * @export
 * @interface ImageParams
 */
export interface ImageParams {
    /**
     * 
     * @type {string}
     * @memberof ImageParams
     */
    prompt?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageParams
     */
    steps?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageParams
     */
    negative_prompt?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageParams
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageParams
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageParams
     */
    denoising_strength?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageParams
     */
    cfg_scale?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageParams
     */
    seed?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageParams
     */
    controlnet_type?: ImageParamsControlnetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ImageParams
     */
    augmentation?: ImageParamsAugmentationEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageParamsControlnetTypeEnum {
    Canny = 'canny',
    Hed = 'hed',
    Depth = 'depth',
    Normal = 'normal',
    Openpose = 'openpose',
    Seg = 'seg',
    Scribble = 'scribble',
    Fakescribbles = 'fakescribbles',
    Hough = 'hough'
}
/**
    * @export
    * @enum {string}
    */
export enum ImageParamsAugmentationEnum {
    FaceRestore = 'face_restore',
    RemoveBackground = 'remove_background',
    Upscale = 'upscale'
}

/**
 * 
 * @export
 * @interface ImageUrls
 */
export interface ImageUrls {
    /**
     * 
     * @type {string}
     * @memberof ImageUrls
     */
    image_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrls
     */
    mask_url?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageUrls
     */
    thumbnail_url?: string;
}
/**
 * 
 * @export
 * @interface InviteCode
 */
export interface InviteCode {
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteCode
     */
    created_at?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteCode
     */
    created_by?: string;
}
/**
 * 
 * @export
 * @interface IsAdminResponse
 */
export interface IsAdminResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IsAdminResponse
     */
    is_admin?: boolean;
}
/**
 * 
 * @export
 * @interface LoginInput
 */
export interface LoginInput {
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginInput
     */
    invite_code?: string;
}
/**
 * 
 * @export
 * @interface LoginResult
 */
export interface LoginResult {
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResult
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface MetricAttribute
 */
export interface MetricAttribute {
    /**
     * 
     * @type {string}
     * @memberof MetricAttribute
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MetricAttribute
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    created_by: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    created_at: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    ends_at: number;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    is_active: boolean;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    gpu_count: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    amount_paid_cents: number;
}
/**
 * 
 * @export
 * @interface RefreshLoginInput
 */
export interface RefreshLoginInput {
    /**
     * 
     * @type {string}
     * @memberof RefreshLoginInput
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StatusEnum {
    Pending = 'pending',
    Processing = 'processing',
    Ranking = 'ranking',
    Completed = 'completed',
    Saved = 'saved',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface TemporaryImage
 */
export interface TemporaryImage {
    /**
     * 
     * @type {string}
     * @memberof TemporaryImage
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TemporaryImage
     */
    upload_url: string;
}
/**
 * 
 * @export
 * @interface UpdateBoostRequest
 */
export interface UpdateBoostRequest {
    /**
     * Boost level to set for current user
     * @type {number}
     * @memberof UpdateBoostRequest
     */
    level?: number;
    /**
     * Whether to activate or deactivate the boost
     * @type {boolean}
     * @memberof UpdateBoostRequest
     */
    is_active?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateBoostResponse
 */
export interface UpdateBoostResponse {
    /**
     * 
     * @type {number}
     * @memberof UpdateBoostResponse
     */
    level?: number;
    /**
     * Balance in 1/2 gpu milliseconds (.1 cents)
     * @type {number}
     * @memberof UpdateBoostResponse
     */
    balance?: number;
    /**
     * Whether the boost is active
     * @type {boolean}
     * @memberof UpdateBoostResponse
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateBoostResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface UpdateGlobalSettingsRequest
 */
export interface UpdateGlobalSettingsRequest {
    /**
     * 
     * @type {object}
     * @memberof UpdateGlobalSettingsRequest
     */
    settings_json: object;
}
/**
 * 
 * @export
 * @interface UpdateImageInput
 */
export interface UpdateImageInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    label?: string;
    /**
     * 
     * @type {StatusEnum}
     * @memberof UpdateImageInput
     */
    status?: StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    encoded_image?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    encoded_npy?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    score?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    negative_score?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateImageInput
     */
    nsfw?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateImageInput
     */
    deleted_at?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateImageInput
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface UpdateLargeImageRequest
 */
export interface UpdateLargeImageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateLargeImageRequest
     */
    image_id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLargeImageRequest
     */
    tmp_image_id: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateLargeImageRequest
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateLargeImageRequest
     */
    y: number;
}
/**
 * 
 * @export
 * @interface UpsertWorkerConfigInput
 */
export interface UpsertWorkerConfigInput {
    /**
     * 
     * @type {Array<WorkerGpuConfig>}
     * @memberof UpsertWorkerConfigInput
     */
    gpu_configs?: Array<WorkerGpuConfig>;
}
/**
 * 
 * @export
 * @interface UpsertWorkerInput
 */
export interface UpsertWorkerInput {
    /**
     * 
     * @type {string}
     * @memberof UpsertWorkerInput
     */
    display_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpsertWorkerInput
     */
    status?: UpsertWorkerInputStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UpsertWorkerInputStatusEnum {
    Idle = 'idle',
    Active = 'active'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface VerifyLoginInput
 */
export interface VerifyLoginInput {
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyLoginInput
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface Worker
 */
export interface Worker {
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof Worker
     */
    created_at: number;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    display_name: string;
    /**
     * 
     * @type {number}
     * @memberof Worker
     */
    last_ping?: number;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    status?: WorkerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    login_code?: string;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    engine?: string;
    /**
     * 
     * @type {number}
     * @memberof Worker
     */
    num_gpus?: number;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    cloud_instance_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Worker
     */
    gpu_type?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WorkerStatusEnum {
    Idle = 'idle',
    Active = 'active'
}

/**
 * 
 * @export
 * @interface WorkerConfig
 */
export interface WorkerConfig {
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    worker_id: string;
    /**
     * 
     * @type {Array<WorkerGpuConfig>}
     * @memberof WorkerConfig
     */
    gpu_configs?: Array<WorkerGpuConfig>;
}
/**
 * 
 * @export
 * @interface WorkerGpuConfig
 */
export interface WorkerGpuConfig {
    /**
     * 
     * @type {number}
     * @memberof WorkerGpuConfig
     */
    gpu_num: number;
    /**
     * 
     * @type {string}
     * @memberof WorkerGpuConfig
     */
    model: string;
}
/**
 * 
 * @export
 * @interface WorkerList
 */
export interface WorkerList {
    /**
     * 
     * @type {Array<Worker>}
     * @memberof WorkerList
     */
    workers?: Array<Worker>;
}
/**
 * 
 * @export
 * @interface WorkerLoginCode
 */
export interface WorkerLoginCode {
    /**
     * 
     * @type {string}
     * @memberof WorkerLoginCode
     */
    login_code: string;
}

/**
 * AIBrushApi - axios parameter creator
 * @export
 */
export const AIBrushApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetrics: async (addMetricsInput?: AddMetricsInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addMetricsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images by id
         * @param {BatchGetImagesInput} [batchGetImagesInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetImages: async (batchGetImagesInput?: BatchGetImagesInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/batch-get-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchGetImagesInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: async (createImageInput?: CreateImageInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a temporary image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTmpImage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tmp-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deposit to a user\'s boost
         * @param {string} userId 
         * @param {DepositRequest} [depositRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositBoost: async (userId: string, depositRequest?: DepositRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('depositBoost', 'userId', userId)
            const localVarPath = `/api/boost/{user_id}/deposit`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log in with Discord
         * @param {DiscordLogin} [discordLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordLogin: async (discordLogin?: DiscordLogin, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/discord-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discordLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/assets-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the boost for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/boost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the boost for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoostForUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getBoostForUser', 'userId', userId)
            const localVarPath = `/api/boost/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the global settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSettings: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getGlobalSettings', 'key', key)
            const localVarPath = `/api/global-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageData', 'id', id)
            const localVarPath = `/api/images/{id}.image.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get download urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDownloadUrls: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageDownloadUrls', 'id', id)
            const localVarPath = `/api/images/{id}/download-urls`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get upload urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageUploadUrls: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getImageUploadUrls', 'id', id)
            const localVarPath = `/api/images/{id}/upload-urls`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaskData', 'id', id)
            const localVarPath = `/api/images/{id}.mask.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getThumbnailData', 'id', id)
            const localVarPath = `/api/images/{id}.thumbnail.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/is-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the boost for all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoosts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/boosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages: async (cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginInput?: LoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshLoginInput?: RefreshLoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the boost level for the current user
         * @param {UpdateBoostRequest} [updateBoostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBoost: async (updateBoostRequest?: UpdateBoostRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/boost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBoostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the global settings
         * @param {string} key 
         * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalSettings: async (key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateGlobalSettings', 'key', key)
            const localVarPath = `/api/global-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlobalSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage: async (id: string, updateImageInput?: UpdateImageInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImage', 'id', id)
            const localVarPath = `/api/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateImageInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a large image
         * @param {UpdateLargeImageRequest} [updateLargeImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLargeImage: async (updateLargeImageRequest?: UpdateLargeImageRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/large-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLargeImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload the binary image data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageData: async (id: string, body?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadImageData', 'id', id)
            const localVarPath = `/api/images/{id}.image.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload the binary thumbnail data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnailData: async (id: string, body?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadThumbnailData', 'id', id)
            const localVarPath = `/api/images/{id}.thumbnail.png`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verifyLoginInput?: VerifyLoginInput, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyLoginInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIBrushApi - functional programming interface
 * @export
 */
export const AIBrushApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIBrushApiAxiosParamCreator(configuration)
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMetrics(addMetricsInput?: AddMetricsInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMetrics(addMetricsInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images by id
         * @param {BatchGetImagesInput} [batchGetImagesInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchGetImages(batchGetImagesInput?: BatchGetImagesInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchGetImages(batchGetImagesInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImage(createImageInput?: CreateImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImage(createImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteCode(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteCode(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a temporary image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTmpImage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemporaryImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTmpImage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deposit to a user\'s boost
         * @param {string} userId 
         * @param {DepositRequest} [depositRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositBoost(userId: string, depositRequest?: DepositRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Boost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositBoost(userId, depositRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Log in with Discord
         * @param {DiscordLogin} [discordLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discordLogin(discordLogin?: DiscordLogin, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discordLogin(discordLogin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsUrl(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetsUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the boost for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Boost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBoost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the boost for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoostForUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Boost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBoostForUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the global settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalSettings(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalSettings(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get download urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageDownloadUrls(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageDownloadUrls(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get upload urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageUploadUrls(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUrls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageUploadUrls(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaskData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaskData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThumbnailData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThumbnailData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Healthcheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAdminResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the boost for all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBoosts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoostList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBoosts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImages(cursor, filter, limit, direction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginInput?: LoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshLoginInput?: RefreshLoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the boost level for the current user
         * @param {UpdateBoostRequest} [updateBoostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBoost(updateBoostRequest?: UpdateBoostRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateBoostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBoost(updateBoostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the global settings
         * @param {string} key 
         * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalSettings(key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGlobalSettings(key, updateGlobalSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImage(id, updateImageInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a large image
         * @param {UpdateLargeImageRequest} [updateLargeImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLargeImage(updateLargeImageRequest?: UpdateLargeImageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLargeImage(updateLargeImageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload the binary image data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadImageData(id: string, body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadImageData(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload the binary thumbnail data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadThumbnailData(id: string, body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadThumbnailData(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verifyLoginInput?: VerifyLoginInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verifyLoginInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AIBrushApi - factory interface
 * @export
 */
export const AIBrushApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIBrushApiFp(configuration)
    return {
        /**
         * Add Metrics
         * @param {AddMetricsInput} [addMetricsInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMetrics(addMetricsInput?: AddMetricsInput, options?: any): AxiosPromise<void> {
            return localVarFp.addMetrics(addMetricsInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images by id
         * @param {BatchGetImagesInput} [batchGetImagesInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetImages(batchGetImagesInput?: BatchGetImagesInput, options?: any): AxiosPromise<ImageList> {
            return localVarFp.batchGetImages(batchGetImagesInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new image
         * @param {CreateImageInput} [createImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageInput?: CreateImageInput, options?: any): AxiosPromise<ImageList> {
            return localVarFp.createImage(createImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new invite code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteCode(options?: any): AxiosPromise<InviteCode> {
            return localVarFp.createInviteCode(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a temporary image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTmpImage(options?: any): AxiosPromise<TemporaryImage> {
            return localVarFp.createTmpImage(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a saved image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deposit to a user\'s boost
         * @param {string} userId 
         * @param {DepositRequest} [depositRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositBoost(userId: string, depositRequest?: DepositRequest, options?: any): AxiosPromise<Boost> {
            return localVarFp.depositBoost(userId, depositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log in with Discord
         * @param {DiscordLogin} [discordLogin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordLogin(discordLogin?: DiscordLogin, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.discordLogin(discordLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the assets url
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsUrl(options?: any): AxiosPromise<AssetsUrl> {
            return localVarFp.getAssetsUrl(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the boost for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoost(options?: any): AxiosPromise<Boost> {
            return localVarFp.getBoost(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the boost for a user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoostForUser(userId: string, options?: any): AxiosPromise<Boost> {
            return localVarFp.getBoostForUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatures(options?: any): AxiosPromise<FeatureList> {
            return localVarFp.getFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the global settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalSettings(key: string, options?: any): AxiosPromise<GlobalSettings> {
            return localVarFp.getGlobalSettings(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a saved image by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImage(id: string, options?: any): AxiosPromise<Image> {
            return localVarFp.getImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary image data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getImageData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get download urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageDownloadUrls(id: string, options?: any): AxiosPromise<ImageUrls> {
            return localVarFp.getImageDownloadUrls(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get upload urls for image assets
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageUploadUrls(id: string, options?: any): AxiosPromise<ImageUrls> {
            return localVarFp.getImageUploadUrls(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary mask data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaskData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMaskData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the binary thumbnail data
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailData(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.getThumbnailData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Healthcheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: any): AxiosPromise<Healthcheck> {
            return localVarFp.healthcheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the user is admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAdmin(options?: any): AxiosPromise<IsAdminResponse> {
            return localVarFp.isAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the boost for all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBoosts(options?: any): AxiosPromise<BoostList> {
            return localVarFp.listBoosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of saved images
         * @param {number} [cursor] 
         * @param {string} [filter] 
         * @param {number} [limit] 
         * @param {'asc' | 'desc'} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: any): AxiosPromise<ImageList> {
            return localVarFp.listImages(cursor, filter, limit, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Login by email
         * @param {LoginInput} [loginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginInput?: LoginInput, options?: any): AxiosPromise<void> {
            return localVarFp.login(loginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh Login code
         * @param {RefreshLoginInput} [refreshLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshLoginInput?: RefreshLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.refresh(refreshLoginInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the boost level for the current user
         * @param {UpdateBoostRequest} [updateBoostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBoost(updateBoostRequest?: UpdateBoostRequest, options?: any): AxiosPromise<UpdateBoostResponse> {
            return localVarFp.updateBoost(updateBoostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the global settings
         * @param {string} key 
         * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalSettings(key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options?: any): AxiosPromise<GlobalSettings> {
            return localVarFp.updateGlobalSettings(key, updateGlobalSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a saved image
         * @param {string} id 
         * @param {UpdateImageInput} [updateImageInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any): AxiosPromise<Image> {
            return localVarFp.updateImage(id, updateImageInput, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a large image
         * @param {UpdateLargeImageRequest} [updateLargeImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLargeImage(updateLargeImageRequest?: UpdateLargeImageRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateLargeImage(updateLargeImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload the binary image data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadImageData(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadImageData(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload the binary thumbnail data
         * @param {string} id 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadThumbnailData(id: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.uploadThumbnailData(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify Login code
         * @param {VerifyLoginInput} [verifyLoginInput] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(verifyLoginInput?: VerifyLoginInput, options?: any): AxiosPromise<LoginResult> {
            return localVarFp.verify(verifyLoginInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIBrushApi - object-oriented interface
 * @export
 * @class AIBrushApi
 * @extends {BaseAPI}
 */
export class AIBrushApi extends BaseAPI {
    /**
     * Add Metrics
     * @param {AddMetricsInput} [addMetricsInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public addMetrics(addMetricsInput?: AddMetricsInput, options?: any) {
        return AIBrushApiFp(this.configuration).addMetrics(addMetricsInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images by id
     * @param {BatchGetImagesInput} [batchGetImagesInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public batchGetImages(batchGetImagesInput?: BatchGetImagesInput, options?: any) {
        return AIBrushApiFp(this.configuration).batchGetImages(batchGetImagesInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new image
     * @param {CreateImageInput} [createImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createImage(createImageInput?: CreateImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).createImage(createImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new invite code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createInviteCode(options?: any) {
        return AIBrushApiFp(this.configuration).createInviteCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a temporary image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public createTmpImage(options?: any) {
        return AIBrushApiFp(this.configuration).createTmpImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a saved image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public deleteImage(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).deleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deposit to a user\'s boost
     * @param {string} userId 
     * @param {DepositRequest} [depositRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public depositBoost(userId: string, depositRequest?: DepositRequest, options?: any) {
        return AIBrushApiFp(this.configuration).depositBoost(userId, depositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log in with Discord
     * @param {DiscordLogin} [discordLogin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public discordLogin(discordLogin?: DiscordLogin, options?: any) {
        return AIBrushApiFp(this.configuration).discordLogin(discordLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the assets url
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getAssetsUrl(options?: any) {
        return AIBrushApiFp(this.configuration).getAssetsUrl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the boost for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getBoost(options?: any) {
        return AIBrushApiFp(this.configuration).getBoost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the boost for a user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getBoostForUser(userId: string, options?: any) {
        return AIBrushApiFp(this.configuration).getBoostForUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getFeatures(options?: any) {
        return AIBrushApiFp(this.configuration).getFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the global settings
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getGlobalSettings(key: string, options?: any) {
        return AIBrushApiFp(this.configuration).getGlobalSettings(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a saved image by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImage(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary image data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImageData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get download urls for image assets
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageDownloadUrls(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImageDownloadUrls(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get upload urls for image assets
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getImageUploadUrls(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getImageUploadUrls(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary mask data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getMaskData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getMaskData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the binary thumbnail data
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public getThumbnailData(id: string, options?: any) {
        return AIBrushApiFp(this.configuration).getThumbnailData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public healthcheck(options?: any) {
        return AIBrushApiFp(this.configuration).healthcheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the user is admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public isAdmin(options?: any) {
        return AIBrushApiFp(this.configuration).isAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the boost for all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listBoosts(options?: any) {
        return AIBrushApiFp(this.configuration).listBoosts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of saved images
     * @param {number} [cursor] 
     * @param {string} [filter] 
     * @param {number} [limit] 
     * @param {'asc' | 'desc'} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public listImages(cursor?: number, filter?: string, limit?: number, direction?: 'asc' | 'desc', options?: any) {
        return AIBrushApiFp(this.configuration).listImages(cursor, filter, limit, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by email
     * @param {LoginInput} [loginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public login(loginInput?: LoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).login(loginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh Login code
     * @param {RefreshLoginInput} [refreshLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public refresh(refreshLoginInput?: RefreshLoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).refresh(refreshLoginInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the boost level for the current user
     * @param {UpdateBoostRequest} [updateBoostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateBoost(updateBoostRequest?: UpdateBoostRequest, options?: any) {
        return AIBrushApiFp(this.configuration).updateBoost(updateBoostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the global settings
     * @param {string} key 
     * @param {UpdateGlobalSettingsRequest} [updateGlobalSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateGlobalSettings(key: string, updateGlobalSettingsRequest?: UpdateGlobalSettingsRequest, options?: any) {
        return AIBrushApiFp(this.configuration).updateGlobalSettings(key, updateGlobalSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a saved image
     * @param {string} id 
     * @param {UpdateImageInput} [updateImageInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateImage(id: string, updateImageInput?: UpdateImageInput, options?: any) {
        return AIBrushApiFp(this.configuration).updateImage(id, updateImageInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a large image
     * @param {UpdateLargeImageRequest} [updateLargeImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public updateLargeImage(updateLargeImageRequest?: UpdateLargeImageRequest, options?: any) {
        return AIBrushApiFp(this.configuration).updateLargeImage(updateLargeImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload the binary image data
     * @param {string} id 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public uploadImageData(id: string, body?: any, options?: any) {
        return AIBrushApiFp(this.configuration).uploadImageData(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload the binary thumbnail data
     * @param {string} id 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public uploadThumbnailData(id: string, body?: any, options?: any) {
        return AIBrushApiFp(this.configuration).uploadThumbnailData(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify Login code
     * @param {VerifyLoginInput} [verifyLoginInput] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIBrushApi
     */
    public verify(verifyLoginInput?: VerifyLoginInput, options?: any) {
        return AIBrushApiFp(this.configuration).verify(verifyLoginInput, options).then((request) => request(this.axios, this.basePath));
    }
}


